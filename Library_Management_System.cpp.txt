#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <sstream>
#include <algorithm>
#include <ctime>

// Define file paths for data storage
const std::string BOOKS_FILE = "books.txt";
const std::string STUDENTS_FILE = "students.txt";
const std::string TRANSACTIONS_FILE = "transactions.txt";

// Represents a single book in the library
struct Book {
    int id;
    std::string title;
    std::string author;
    bool isIssued;

    // Default constructor
    Book() : id(0), isIssued(false) {}

    // Parameterized constructor
    Book(int i, std::string t, std::string a, bool issued)
        : id(i), title(t), author(a), isIssued(issued) {}
};

// Represents a student member of the library
struct Student {
    int id;
    std::string name;

    // Default constructor
    Student() : id(0) {}

    // Parameterized constructor
    Student(int i, std::string n) : id(i), name(n) {}
};

// Represents a single transaction (issue or return)
struct Transaction {
    int transactionId;
    int bookId;
    int studentId;
    std::string issueDate;
    std::string returnDate;

    // Default constructor
    Transaction() : transactionId(0), bookId(0), studentId(0) {}

    // Parameterized constructor
    Transaction(int tId, int bId, int sId, std::string iDate)
        : transactionId(tId), bookId(bId), studentId(sId), issueDate(iDate), returnDate("N/A") {}
};


// Helper function to get current date as a string
std::string getCurrentDate() {
    time_t now = time(0);
    tm *ltm = localtime(&now);
    std::string date = std::to_string(1900 + ltm->tm_year) + "-" +
                     std::to_string(1 + ltm->tm_mon) + "-" +
                     std::to_string(ltm->tm_mday);
    return date;
}

// Main class to manage all library operations
class Library {
private:
    std::vector<Book> books;
    std::vector<Student> students;
    std::vector<Transaction> transactions;
    int nextBookId = 1;
    int nextStudentId = 1;
    int nextTransactionId = 1;

    // --- Data Persistence ---

    // Load all data from files into memory
    void loadData() {
        loadBooks();
        loadStudents();
        loadTransactions();
    }

    // Load books from books.txt
    void loadBooks() {
        std::ifstream file(BOOKS_FILE);
        if (!file.is_open()) return;
        std::string line;
        int maxId = 0;
        while (getline(file, line)) {
            std::stringstream ss(line);
            std::string item;
            std::vector<std::string> tokens;
            while (getline(ss, item, ',')) {
                tokens.push_back(item);
            }
            if (tokens.size() == 4) {
                Book book(std::stoi(tokens[0]), tokens[1], tokens[2], (tokens[3] == "1"));
                books.push_back(book);
                if (book.id > maxId) maxId = book.id;
            }
        }
        nextBookId = maxId + 1;
        file.close();
    }

    // Load students from students.txt
    void loadStudents() {
        std::ifstream file(STUDENTS_FILE);
        if (!file.is_open()) return;
        std::string line;
        int maxId = 0;
        while (getline(file, line)) {
            std::stringstream ss(line);
            std::string item;
            std::vector<std::string> tokens;
            while (getline(ss, item, ',')) {
                tokens.push_back(item);
            }
            if (tokens.size() == 2) {
                Student student(std::stoi(tokens[0]), tokens[1]);
                students.push_back(student);
                if (student.id > maxId) maxId = student.id;
            }
        }
        nextStudentId = maxId + 1;
        file.close();
    }
    
    // Load transactions from transactions.txt
    void loadTransactions() {
        std::ifstream file(TRANSACTIONS_FILE);
        if (!file.is_open()) return;
        std::string line;
        int maxId = 0;
        while (getline(file, line)) {
            std::stringstream ss(line);
            std::string item;
            std::vector<std::string> tokens;
            while (getline(ss, item, ',')) {
                tokens.push_back(item);
            }
            if (tokens.size() == 5) {
                Transaction t;
                t.transactionId = std::stoi(tokens[0]);
                t.bookId = std::stoi(tokens[1]);
                t.studentId = std::stoi(tokens[2]);
                t.issueDate = tokens[3];
                t.returnDate = tokens[4];
                transactions.push_back(t);
                 if (t.transactionId > maxId) maxId = t.transactionId;
            }
        }
        nextTransactionId = maxId + 1;
        file.close();
    }

    // Save all data from memory to files
    void saveData() {
        saveBooks();
        saveStudents();
        saveTransactions();
    }

    // Save books to books.txt
    void saveBooks() {
        std::ofstream file(BOOKS_FILE);
        for (const auto& book : books) {
            file << book.id << "," << book.title << "," << book.author << "," << book.isIssued << "\n";
        }
        file.close();
    }

    // Save students to students.txt
    void saveStudents() {
        std::ofstream file(STUDENTS_FILE);
        for (const auto& student : students) {
            file << student.id << "," << student.name << "\n";
        }
        file.close();
    }
    
    // Save transactions to transactions.txt
    void saveTransactions() {
        std::ofstream file(TRANSACTIONS_FILE);
        for (const auto& t : transactions) {
            file << t.transactionId << "," << t.bookId << "," << t.studentId << "," << t.issueDate << "," << t.returnDate << "\n";
        }
        file.close();
    }

public:
    // Constructor: Loads data when the object is created
    Library() {
        loadData();
    }

    // Destructor: Saves data when the object is destroyed
    ~Library() {
        saveData();
    }

    // --- Core Features ---

    // Add a new book to the library
    void addBook() {
        std::string title, author;
        std::cout << "Enter Book Title: ";
        std::cin.ignore();
        getline(std::cin, title);
        std::cout << "Enter Book Author: ";
        getline(std::cin, author);

        books.emplace_back(nextBookId++, title, author, false);
        std::cout << "\nBook added successfully! (ID: " << books.back().id << ")\n";
    }
    
    // Add a new student to the library system
    void addStudent() {
        std::string name;
        std::cout << "Enter Student Name: ";
        std::cin.ignore();
        getline(std::cin, name);

        students.emplace_back(nextStudentId++, name);
        std::cout << "\nStudent added successfully! (ID: " << students.back().id << ")\n";
    }

    // Issue a book to a student
    void issueBook() {
        int bookId, studentId;
        std::cout << "Enter Book ID to issue: ";
        std::cin >> bookId;
        std::cout << "Enter Student ID: ";
        std::cin >> studentId;

        auto bookIt = std::find_if(books.begin(), books.end(), [bookId](const Book& b) {
            return b.id == bookId;
        });

        auto studentIt = std::find_if(students.begin(), students.end(), [studentId](const Student& s) {
            return s.id == studentId;
        });

        if (bookIt == books.end()) {
            std::cout << "\nError: Book with ID " << bookId << " not found.\n";
            return;
        }

        if (studentIt == students.end()) {
            std::cout << "\nError: Student with ID " << studentId << " not found.\n";
            return;
        }

        if (bookIt->isIssued) {
            std::cout << "\nError: Book is already issued.\n";
            return;
        }

        bookIt->isIssued = true;
        transactions.emplace_back(nextTransactionId++, bookId, studentId, getCurrentDate());
        std::cout << "\nBook '" << bookIt->title << "' issued to '" << studentIt->name << "' successfully!\n";
    }

    // Return a book from a student
    void returnBook() {
        int bookId;
        std::cout << "Enter Book ID to return: ";
        std::cin >> bookId;

        auto bookIt = std::find_if(books.begin(), books.end(), [bookId](const Book& b) {
            return b.id == bookId;
        });

        if (bookIt == books.end()) {
            std::cout << "\nError: Book with ID " << bookId << " not found.\n";
            return;
        }

        if (!bookIt->isIssued) {
            std::cout << "\nError: Book was not issued.\n";
            return;
        }

        bookIt->isIssued = false;

        // Find the corresponding transaction and update the return date
        auto transIt = std::find_if(transactions.rbegin(), transactions.rend(), [bookId](const Transaction& t) {
            return t.bookId == bookId && t.returnDate == "N/A";
        });

        if (transIt != transactions.rend()) {
            transIt->returnDate = getCurrentDate();
        }

        std::cout << "\nBook '" << bookIt->title << "' returned successfully!\n";
    }

    // --- Display Functions ---

    // Display all books in the library
    void displayAllBooks() {
        std::cout << "\n--- Library Book Inventory ---\n";
        std::cout << "ID\tTitle\t\tAuthor\t\tStatus\n";
        std::cout << "------------------------------------------------------\n";
        if (books.empty()) {
            std::cout << "No books in the library.\n";
        } else {
            for (const auto& book : books) {
                std::cout << book.id << "\t" << book.title << "\t\t" << book.author << "\t\t"
                          << (book.isIssued ? "Issued" : "Available") << "\n";
            }
        }
        std::cout << "------------------------------------------------------\n";
    }
    
    // Display all registered students
    void displayAllStudents() {
        std::cout << "\n--- Registered Students ---\n";
        std::cout << "ID\tName\n";
        std::cout << "---------------------------\n";
        if (students.empty()) {
            std::cout << "No students registered.\n";
        } else {
            for (const auto& student : students) {
                std::cout << student.id << "\t" << student.name << "\n";
            }
        }
        std::cout << "---------------------------\n";
    }

    // Display all transaction records
    void displayTransactions() {
        std::cout << "\n--- Transaction History ---\n";
        std::cout << "T.ID\tB.ID\tS.ID\tIssue Date\tReturn Date\n";
        std::cout << "------------------------------------------------------\n";
        if (transactions.empty()) {
            std::cout << "No transactions recorded.\n";
        } else {
            for (const auto& t : transactions) {
                std::cout << t.transactionId << "\t" << t.bookId << "\t" << t.studentId << "\t"
                          << t.issueDate << "\t" << t.returnDate << "\n";
            }
        }
        std::cout << "------------------------------------------------------\n";
    }
};

// Function to display the main menu
void showMenu() {
    std::cout << "\n===== Library Management System =====\n";
    std::cout << "1. Add New Book\n";
    std::cout << "2. Add New Student\n";
    std::cout << "3. Issue Book\n";
    std::cout << "4. Return Book\n";
    std::cout << "5. List All Books\n";
    std::cout << "6. List All Students\n";
    std::cout << "7. List All Transactions\n";
    std::cout << "8. Exit\n";
    std::cout << "=====================================\n";
    std::cout << "Enter your choice: ";
}

// Main function - entry point of the program
int main() {
    Library library;
    int choice;

    do {
        showMenu();
        std::cin >> choice;

        // Input validation
        if (std::cin.fail()) {
            std::cin.clear(); // clear input buffer to restore cin to a usable state
            std::cin.ignore(10000, '\n'); // ignore last input
            std::cout << "\nInvalid input. Please enter a number.\n";
            choice = 0; // Set choice to a value that doesn't exit
            continue;
        }

        switch (choice) {
            case 1:
                library.addBook();
                break;
            case 2:
                library.addStudent();
                break;
            case 3:
                library.issueBook();
                break;
            case 4:
                library.returnBook();
                break;
            case 5:
                library.displayAllBooks();
                break;
            case 6:
                library.displayAllStudents();
                break;
            case 7:
                library.displayTransactions();
                break;
            case 8:
                std::cout << "\nExiting program. All data has been saved.\n";
                break;
            default:
                std::cout << "\nInvalid choice. Please try again.\n";
        }
    } while (choice != 8);

    return 0;
}
